<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 是怎么工作的 | tombstone</title>
    <meta name="description" content="tombstone docs">
    <link rel="icon" href="/tombstone/favicon.ico">
    
    <link rel="preload" href="/tombstone/assets/css/0.styles.0ea869b6.css" as="style"><link rel="preload" href="/tombstone/assets/js/app.0bf91f49.js" as="script"><link rel="preload" href="/tombstone/assets/js/2.94ea3c73.js" as="script"><link rel="preload" href="/tombstone/assets/js/3.994d5515.js" as="script"><link rel="prefetch" href="/tombstone/assets/js/10.c8430b82.js"><link rel="prefetch" href="/tombstone/assets/js/11.70ce923e.js"><link rel="prefetch" href="/tombstone/assets/js/12.799f10f8.js"><link rel="prefetch" href="/tombstone/assets/js/13.59dea27b.js"><link rel="prefetch" href="/tombstone/assets/js/14.e2894561.js"><link rel="prefetch" href="/tombstone/assets/js/15.b3361845.js"><link rel="prefetch" href="/tombstone/assets/js/16.f12a87e1.js"><link rel="prefetch" href="/tombstone/assets/js/17.cb76376d.js"><link rel="prefetch" href="/tombstone/assets/js/18.c0ee4e0f.js"><link rel="prefetch" href="/tombstone/assets/js/19.7b1edbe4.js"><link rel="prefetch" href="/tombstone/assets/js/20.9133dfa2.js"><link rel="prefetch" href="/tombstone/assets/js/21.075b6cfe.js"><link rel="prefetch" href="/tombstone/assets/js/22.93e71a2c.js"><link rel="prefetch" href="/tombstone/assets/js/23.4435101b.js"><link rel="prefetch" href="/tombstone/assets/js/24.2488c6c6.js"><link rel="prefetch" href="/tombstone/assets/js/25.41148fef.js"><link rel="prefetch" href="/tombstone/assets/js/26.62938a6b.js"><link rel="prefetch" href="/tombstone/assets/js/27.de56081a.js"><link rel="prefetch" href="/tombstone/assets/js/28.c17c615c.js"><link rel="prefetch" href="/tombstone/assets/js/29.d7a9e410.js"><link rel="prefetch" href="/tombstone/assets/js/30.385b8f69.js"><link rel="prefetch" href="/tombstone/assets/js/31.ebb683e5.js"><link rel="prefetch" href="/tombstone/assets/js/32.1593268f.js"><link rel="prefetch" href="/tombstone/assets/js/33.13aa73aa.js"><link rel="prefetch" href="/tombstone/assets/js/34.49c57481.js"><link rel="prefetch" href="/tombstone/assets/js/35.3e46ab0f.js"><link rel="prefetch" href="/tombstone/assets/js/36.5be3d8af.js"><link rel="prefetch" href="/tombstone/assets/js/37.9a34f4fc.js"><link rel="prefetch" href="/tombstone/assets/js/38.90c7c8c2.js"><link rel="prefetch" href="/tombstone/assets/js/39.106fbb40.js"><link rel="prefetch" href="/tombstone/assets/js/4.8aa69369.js"><link rel="prefetch" href="/tombstone/assets/js/40.b6e0c507.js"><link rel="prefetch" href="/tombstone/assets/js/41.b7142d30.js"><link rel="prefetch" href="/tombstone/assets/js/42.62a4c3cf.js"><link rel="prefetch" href="/tombstone/assets/js/43.6a70fccb.js"><link rel="prefetch" href="/tombstone/assets/js/5.3e8c569c.js"><link rel="prefetch" href="/tombstone/assets/js/6.be3e8088.js"><link rel="prefetch" href="/tombstone/assets/js/7.ec138f83.js"><link rel="prefetch" href="/tombstone/assets/js/8.04a8bcd5.js"><link rel="prefetch" href="/tombstone/assets/js/9.46190c4b.js">
    <link rel="stylesheet" href="/tombstone/assets/css/0.styles.0ea869b6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tombstone/" class="home-link router-link-active"><!----> <span class="site-name">tombstone</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tombstone/about.html" class="nav-link">about</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tombstone/about.html" class="nav-link">about</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/tombstone/" class="sidebar-link">Home</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/tombstone/handbook/" class="sidebar-heading clickable"><span>手册</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/tombstone/frontend/" class="sidebar-heading clickable router-link-active open"><span>前端</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tombstone/frontend/browser/howbrowserworks.html" class="sidebar-link">浏览器是怎么工作的</a></li><li><a href="/tombstone/frontend/performance/" class="sidebar-link">前端性能优化</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/tombstone/frontend/javascript/" class="sidebar-heading clickable router-link-active open"><span>JavaScript</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tombstone/frontend/javascript/howjsworks.html" class="active sidebar-link">JS 是怎么工作的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#the-js-engine" class="sidebar-link">The JS Engine</a></li><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#the-runtime-运行时" class="sidebar-link">The Runtime (运行时)</a></li><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#the-call-stack" class="sidebar-link">The Call Stack</a></li><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#the-event-loop" class="sidebar-link">The Event Loop</a></li><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#内存管理" class="sidebar-link">内存管理</a></li><li class="sidebar-sub-header"><a href="/tombstone/frontend/javascript/howjsworks.html#参考文章" class="sidebar-link">参考文章</a></li></ul></li><li><a href="/tombstone/frontend/javascript/crossorigin.html" class="sidebar-link">浏览器同源策略与 ajax 跨域方法</a></li><li><a href="/tombstone/frontend/javascript/jsapi.html" class="sidebar-link">JS API</a></li><li><a href="/tombstone/frontend/javascript/dom.html" class="sidebar-link">DOM</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/tombstone/frontend/css/" class="sidebar-heading clickable"><span>CSS</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tombstone/frontend/css/selector.html" class="sidebar-link">选择器、优先级、继承和级联</a></li><li><a href="/tombstone/frontend/css/properties.html" class="sidebar-link">常用 CSS 属性</a></li><li><a href="/tombstone/frontend/css/box.html" class="sidebar-link">盒模型与外边距重叠</a></li><li><a href="/tombstone/frontend/css/csslayout.html" class="sidebar-link">CSS 布局</a></li><li><a href="/tombstone/frontend/css/containingblock.html" class="sidebar-link">包含块</a></li><li><a href="/tombstone/frontend/css/stackingcontext.html" class="sidebar-link">层叠上下文</a></li><li><a href="/tombstone/frontend/css/bfc.html" class="sidebar-link">Block Formatting Context</a></li><li><a href="/tombstone/frontend/css/cssom.html" class="sidebar-link">CSSOM</a></li></ul></section></li><li><a href="/tombstone/frontend/security/" class="sidebar-link">前端安全问题</a></li><li><a href="/tombstone/frontend/typescript/" class="sidebar-link">TypeScript</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/tombstone/frontend/library/" class="sidebar-heading clickable"><span>前端框架</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tombstone/frontend/library/react.html" class="sidebar-link">React</a></li><li><a href="/tombstone/frontend/library/redux.html" class="sidebar-link">Redux</a></li><li><a href="/tombstone/frontend/library/reactimvc.html" class="sidebar-link">React-IMVC</a></li><li><a href="/tombstone/frontend/library/immer.html" class="sidebar-link">Immer</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/tombstone/frontend/tools/" class="sidebar-heading clickable"><span>工程化与工具</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tombstone/frontend/tools/babel.html" class="sidebar-link">Babel</a></li><li><a href="/tombstone/frontend/tools/webpack.html" class="sidebar-link">Webpack</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/tombstone/server/" class="sidebar-heading clickable"><span>服务端</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/tombstone/blog/" class="sidebar-link">文章</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-是怎么工作的"><a href="#js-是怎么工作的" aria-hidden="true" class="header-anchor">#</a> JS 是怎么工作的</h1> <h2 id="the-js-engine"><a href="#the-js-engine" aria-hidden="true" class="header-anchor">#</a> The JS Engine</h2> <p>最常见的 JS 引擎是 Chrome 和 Node.js 使用的 Google's V8 Engine。引擎一般由两部分组成：</p> <ul><li>Memory Heap(内存堆) -- 负责内存分配</li> <li>Call Stack(调用栈) -- 代码执行时分配 stack frames(栈帧)</li></ul> <h2 id="the-runtime-运行时"><a href="#the-runtime-运行时" aria-hidden="true" class="header-anchor">#</a> The Runtime (运行时)</h2> <p>以浏览器为例，除了 JS 引擎， 还提供 Web APIs， Event Loop， Callback Quene 等。</p> <p><img src="/tombstone/assets/img/runtime.30ab862a.png" alt="runtime"></p> <h2 id="the-call-stack"><a href="#the-call-stack" aria-hidden="true" class="header-anchor">#</a> The Call Stack</h2> <p>JS 是单线程的，只有一个调用栈，一次只能做一件事情。</p> <p>调用栈是记录程序执行位置的数据结构，开始执行一个函数时，往栈里推入一个栈帧，函数执行结束时，弹出顶部的栈帧。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">printSquare</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">printSquare</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/tombstone/assets/img/callstack.0340408b.png" alt="call stack"></p> <p>调用栈有最大栈帧数（maximum Call Stack size）限制，超过了就抛出爆栈错误。比如递归没加退出条件。</p> <h2 id="the-event-loop"><a href="#the-event-loop" aria-hidden="true" class="header-anchor">#</a> The Event Loop</h2> <h3 id="概念"><a href="#概念" aria-hidden="true" class="header-anchor">#</a> 概念</h3> <ul><li>event loop
<ul><li>为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用 event loop</li></ul></li> <li>task
<ul><li>一个event loop有一个或者多个task队列</li> <li>当用户代理安排一个任务，必须将该任务增加到相应的event loop的一个tsak队列中</li> <li>每一个task都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个task队列，其他事件又是一个单独的队列。可以为鼠标、键盘事件分配更多的时间，保证交互的流畅。</li> <li>task 任务源
<ul><li>script 整体代码</li> <li>setTimeout, setInterval, setImmediate</li> <li>I/O</li> <li>UI rendering</li></ul></li></ul></li> <li>microtask
<ul><li>每一个 event loop 都有一个 microtask 队列，一个 microtask 会被排进 microtask 队列而不是 task 队列。</li> <li>microtask 任务源
<ul><li>process.nextTick</li> <li>Promise</li> <li>Object.observe</li> <li>MutationObserver</li></ul></li> <li>注：Promise 规范里提及 then 方法可以采用宏任务，也可以采用微任务来实现。普遍共识是用微任务。</li></ul></li></ul> <h3 id="event-loop-处理过程（processing-model）"><a href="#event-loop-处理过程（processing-model）" aria-hidden="true" class="header-anchor">#</a> event loop 处理过程（Processing model）</h3> <blockquote><p>一个event loop只要存在，就会不断执行下边的步骤：</p> <ol><li>在tasks队列中选择最老的一个task,用户代理可以选择任何task队列，如果没有可选的任务，则跳到下边的microtasks步骤。</li> <li>将上边选择的task设置为正在运行的task。</li> <li>Run: 运行被选择的task。</li> <li>将event loop的currently running task变为null。</li> <li>从task队列里移除前边运行的task。</li> <li>Microtasks: 执行microtasks任务检查点。（也就是执行microtasks队列里的任务）</li> <li>更新渲染（Update the rendering）...</li> <li>如果这是一个worker event loop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。</li> <li>返回到第一步。</li></ol></blockquote> <p>event loop 不断循环上面的步骤， 其中第七步更新渲染是可能有的。</p> <p>关于渲染更新：</p> <ul><li>在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。</li> <li>渲染更新（Update the rendering）会在event loop中的tasks和microtasks完成后进行，但并不是每轮event loop都会更新渲染，这取决于是否修改了dom和浏览器觉得是否有必要在此时立即将新状态呈现给用户。如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处dom，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。</li> <li>如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame。</li></ul> <h3 id="node-js-中的-event-loop"><a href="#node-js-中的-event-loop" aria-hidden="true" class="header-anchor">#</a> Node.js 中的 Event Loop</h3> <p>Node.js 里的 Event Loop 和浏览器里的是完全不同的东西， 由 libuv 驱动。</p> <p><img src="/tombstone/assets/img/libuveventloop.72d26b0e.png" alt="libuv event loop"></p> <p>libuv 引擎中的事件循环分为 6 个阶段， 会按照顺序反复运行。外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p> <ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li> <li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li> <li>idle, prepare 阶段：仅 node 内部使用</li> <li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li> <li>check 阶段：执行 setImmediate() 的回调</li> <li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul> <h4 id="poll"><a href="#poll" aria-hidden="true" class="header-anchor">#</a> poll</h4> <p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p> <ul><li>回到 timer 阶段执行回调</li> <li>执行 I/O 回调</li></ul> <p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p> <ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li> <li>如果 poll 队列为空时，会有两件事发生
<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li> <li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul> <p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p> <h4 id="注意点"><a href="#注意点" aria-hidden="true" class="header-anchor">#</a> 注意点</h4> <ul><li>setTimeout 和 setImmediate
<ul><li>对于以下代码来说，setTimeout 可能执行在前，也可能执行在后。</li> <li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的
<ul><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li></ul></li> <li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timeout</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">immediate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout</p> <ul><li>precess.nextTick
<ul><li>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span>
 process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span>
   process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span>
     process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;promise1=&gt;timer1</span>
</code></pre></div><h3 id="浏览器和-node-js-中-event-loop-对比"><a href="#浏览器和-node-js-中-event-loop-对比" aria-hidden="true" class="header-anchor">#</a> 浏览器和 Node.js 中 Event Loop 对比</h3> <p>浏览器环境下，microtasks 的任务队列是在每个 macrotask 执行完之后执行。而在 Node.js 中，microtasks 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtasks 队列的任务。</p> <p><img src="/tombstone/assets/img/eventloopcompare.336c06ec.png" alt="event loop compare"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">// 浏览器端运行结果：timer1=&gt;promise1=&gt;timer2=&gt;promise2</span>
<span class="token comment">// Node 端运行结果：timer1=&gt;timer2=&gt;promise1=&gt;promise2</span>
</code></pre></div><h2 id="内存管理"><a href="#内存管理" aria-hidden="true" class="header-anchor">#</a> 内存管理</h2> <p>C 语言有 <code>malloc()</code> 和 <code>free()</code> 来分配和回收内存。</p> <p>内存生命周期： <code>allocate memory</code> --&gt; <code>use memory</code> --&gt; <code>release memory</code></p> <h3 id="内存分配"><a href="#内存分配" aria-hidden="true" class="header-anchor">#</a> 内存分配</h3> <ul><li>静态分配
<ul><li>内存分配在栈空间（stack space），分配固定的大小</li> <li>函数调用函数时，每个函数获取对应的一块栈空间，用来保存本地变量</li> <li>函数调用结束，按 LIFO(last-in-first-out) 顺序释放</li></ul></li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment">// 4 bytes</span>
<span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of 4 elements, each 4 bytes</span>
<span class="token keyword">double</span> m<span class="token punctuation">;</span> <span class="token comment">// 8 bytes</span>
</code></pre></div><ul><li>动态分配：内存分配在堆空间（heap space）</li></ul> <p><img src="/tombstone/assets/img/allocation.9e8b0ab8.png" alt="allocation"></p> <h3 id="垃圾回收"><a href="#垃圾回收" aria-hidden="true" class="header-anchor">#</a> 垃圾回收</h3> <ul><li>引用计数（Reference-counting garbage collection）
<ul><li>一个对象被引用次数为 0 时，被认为是可回收的</li> <li>没法解决循环引用的问题</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  o2<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 2 objects are created. </span>
<span class="token comment">// 'o2' is referenced by 'o1' object as one of its properties.</span>
<span class="token comment">// None can be garbage-collected</span>

<span class="token keyword">var</span> o3 <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment">// the 'o3' variable is the second thing that </span>
            <span class="token comment">// has a reference to the object pointed by 'o1'. </span>
                                                       
o1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// now, the object that was originally in 'o1' has a         </span>
            <span class="token comment">// single reference, embodied by the 'o3' variable</span>

<span class="token keyword">var</span> o4 <span class="token operator">=</span> o3<span class="token punctuation">.</span>o2<span class="token punctuation">;</span> <span class="token comment">// reference to 'o2' property of the object.</span>
                <span class="token comment">// This object has now 2 references: one as</span>
                <span class="token comment">// a property. </span>
                <span class="token comment">// The other as the 'o4' variable</span>

o3 <span class="token operator">=</span> <span class="token string">'374'</span><span class="token punctuation">;</span> <span class="token comment">// The object that was originally in 'o1' has now zero</span>
            <span class="token comment">// references to it. </span>
            <span class="token comment">// It can be garbage-collected.</span>
            <span class="token comment">// However, what was its 'o2' property is still</span>
            <span class="token comment">// referenced by the 'o4' variable, so it cannot be</span>
            <span class="token comment">// freed.</span>

o4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// what was the 'o2' property of the object originally in</span>
           <span class="token comment">// 'o1' has zero references to it. </span>
           <span class="token comment">// It can be garbage collected.</span>
</code></pre></div><p>循环引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o1<span class="token punctuation">.</span>p <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o1 references o2</span>
  o2<span class="token punctuation">.</span>p <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment">// o2 references o1. This creates a cycle.</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>标记清除（Mark-and-sweep algorithm）</li></ul> <p>步骤：</p> <ol><li>Roots: In general, roots are global variables which get referenced in the code. In JavaScript for example, a global variable that can act as a root is the “window” object. The identical object in Node.js is called “global”. A complete list of all roots gets built by the garbage collector.</li> <li>The algorithm then inspects all roots and their children and marks them as active (meaning, they are not garbage). Anything that a root cannot reach will be marked as garbage.</li> <li>Finally, the garbage collector frees all memory pieces that are not marked as active and returns that memory to the OS.</li></ol> <p><img src="/tombstone/assets/img/marksweep.0833d209.gif" alt="mark and sweep"></p> <h3 id="js-中常见的内存泄漏"><a href="#js-中常见的内存泄漏" aria-hidden="true" class="header-anchor">#</a> JS 中常见的内存泄漏</h3> <ul><li>Global variables</li> <li>Timers or Callbacks that are forgotten</li> <li>Closures</li> <li>Out of DOM references</li></ul> <h2 id="参考文章"><a href="#参考文章" aria-hidden="true" class="header-anchor">#</a> 参考文章</h2> <ul><li><a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener noreferrer">How JavaScript works: an overview of the engine, the runtime, and the call stack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/aooy/blog/issues/5" target="_blank" rel="noopener noreferrer">从event loop规范探究javaScript异步及浏览器更新渲染时机<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/" target="_blank" rel="noopener noreferrer">浏览器与Node的事件循环(Event Loop)有何区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener noreferrer">How JavaScript works: memory management + how to handle 4 common memory leaks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tombstone/frontend/performance/" class="prev">前端性能优化</a></span> <span class="next"><a href="/tombstone/frontend/javascript/crossorigin.html">浏览器同源策略与 ajax 跨域方法</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/tombstone/assets/js/app.0bf91f49.js" defer></script><script src="/tombstone/assets/js/2.94ea3c73.js" defer></script><script src="/tombstone/assets/js/3.994d5515.js" defer></script>
  </body>
</html>
